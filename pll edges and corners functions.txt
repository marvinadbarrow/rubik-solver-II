// object holding conditions of different stages after they are tested. 
let stageConditionObj = {
  'cross': [], // just the cross pieces
  'F2L': [], // contains objects holding corner and edge F2L pieces
  'OLL_edges': [], // just the last layer edges
  'OLL_corners': [],
  'PLL_corners': [],
  'PLL_edges': []
}


pll edges and corners functions

function assessPLLCorners(){
console.log('assessing PLL corners')
// variable for the number of edges assessed
let totalCornersAssessed = 0;
let completeArray = []
upLayerCorners.forEach((corner) =>{
  // check the color facets of the current corner, and push the natural index that the corner piece should sit on in the solved state. This will create a permutation; of which there are 24, but, there are six base permutations, each of the other 18 are just rotated versions of one of the six base permutations. 
     if(corner[1] == 'r' && corner [2] == 'g'){
      completeArray.push(0)
    }else if(corner[1] == 'o' && corner [2] == 'g'){
      completeArray.push(1)
    }else if(corner[1] == 'o' && corner [2] == 'b'){
      completeArray.push(2)
    }else if(corner[1] == 'r' && corner [2] == 'b'){
      completeArray.push(3)
    }
    totalCornersAssessed ++
})

if(totalCornersAssessed > 3){
  console.log(completeArray)
}

}

function assessPLLEdges(){
console.log('assessing PLL edges')
// variable for the number of edges assessed
let totalEdgesAssessed = 0;
// array to hold natural index values of edge pieces
let completeArray = []
upLayerEdges.forEach((edge, index) =>{
  // check the color of the side facet on the edge at the current index, and push the index which is the natural index of the color facet, that is, where the index at which the facet should sit when the cube is solved. 
  if(edge[1] == 'r'){
    completeArray.push(0)
  }else if(edge[1] == 'g'){
    completeArray.push(1)
  }else if(edge[1] == 'o'){
    completeArray.push(2)
  }else if(edge[1] == 'b'){
    completeArray.push(3)
  }
edgesAssessedTotal ++
})


}





// PLL CORNERS ASSESSMENT FUNCTION
function assessPLLCorners(){
console.log('assessing PLL corners')

// array for completed F2L corners
let permutationArray = []
let cornersAssessedTotal = 0
upLayerCorners.forEach((corner, index) =>{

        // check which corner facet details and push the natural index that the corner belongs to, to the permutation array.   Each position in the permutation array represents an index position on the cube corners; so if the permutation array is not [0, 1, 2, 3], but some other permutation, then some or all of the corners are incorrectly placed.  And based on the permutation, an algorithm can be determined to rearrange the corners to the 'identity' permutation above. 
        if((corner[1] == 'r' && corner [2] == 'g')){
          permutationArray.push(0)
        }else if((corner[1] == 'o' && corner [2] == 'g')){
          permutationArray.push(1)
        }else if((corner[1] == 'o' && corner [2] == 'b')){
          permutationArray.push(2)
        }else if((corner[1] == 'r' && corner [2] == 'b')){
          permutationArray.push(3)
        }
cornersAssessedTotal ++
})

if(cornersAssessedTotal > 3){
  console.log('permutationArray')
  console.log(permutationArray)
 
}

}