// object holding conditions of different stages after they are tested. 
let stageConditionObj = {
  'cross': [], // just the cross pieces
  'F2L': [], // contains objects holding corner and edge F2L pieces
  'OLL_edges': [], // just the last layer edges
  'OLL_corners': [],
  'PLL_corners': [],
  'PLL_edges': []
}


pll edges and corners functions

function assessPLLCorners(){
console.log('assessing PLL corners')
// variable for the number of edges assessed
let totalCornersAssessed = 0;
let completeArray = []
upLayerCorners.forEach((corner) =>{
  // check the color facets of the current corner, and push the natural index that the corner piece should sit on in the solved state. This will create a permutation; of which there are 24, but, there are six base permutations, each of the other 18 are just rotated versions of one of the six base permutations. 
     if(corner[1] == 'r' && corner [2] == 'g'){
      completeArray.push(0)
    }else if(corner[1] == 'o' && corner [2] == 'g'){
      completeArray.push(1)
    }else if(corner[1] == 'o' && corner [2] == 'b'){
      completeArray.push(2)
    }else if(corner[1] == 'r' && corner [2] == 'b'){
      completeArray.push(3)
    }
    totalCornersAssessed ++
})

if(totalCornersAssessed > 3){
  console.log(completeArray)
}

}

function assessPLLEdges(){
console.log('assessing PLL edges')
// variable for the number of edges assessed
let totalEdgesAssessed = 0;
// array to hold natural index values of edge pieces
let completeArray = []
upLayerEdges.forEach((edge, index) =>{
  // check the color of the side facet on the edge at the current index, and push the index which is the natural index of the color facet, that is, where the index at which the facet should sit when the cube is solved. 
  if(edge[1] == 'r'){
    completeArray.push(0)
  }else if(edge[1] == 'g'){
    completeArray.push(1)
  }else if(edge[1] == 'o'){
    completeArray.push(2)
  }else if(edge[1] == 'b'){
    completeArray.push(3)
  }
edgesAssessedTotal ++
})


}